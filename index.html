<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Webcam Streaming - Ultra Low Latency</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Helvetica Neue", sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.05);
            max-width: 800px;
            width: 100%;
            padding: 48px;
        }

        h1 {
            text-align: center;
            color: #1d1d1f;
            margin-bottom: 8px;
            font-size: 2.5em;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .subtitle {
            text-align: center;
            color: #86868b;
            margin-bottom: 40px;
            font-size: 1em;
            font-weight: 400;
        }

        .mode-selector {
            display: inline-flex;
            background: #f5f5f7;
            border-radius: 10px;
            padding: 2px;
            margin: 0 auto 40px;
            width: 100%;
            max-width: 400px;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
        }

        .mode-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #1d1d1f;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
        }

        .mode-btn:hover {
            color: #007AFF;
        }

        .mode-btn.active {
            background: #ffffff;
            color: #007AFF;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.05);
        }

        .panel {
            display: none;
        }

        .panel.active {
            display: block;
        }

        .info-box {
            background: #f5f5f7;
            border-left: 3px solid #007AFF;
            padding: 16px 20px;
            margin-bottom: 24px;
            border-radius: 8px;
        }

        .info-box strong {
            color: #007AFF;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #1d1d1f;
            font-weight: 500;
            font-size: 0.95em;
        }

        input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.2s;
            background: #ffffff;
            color: #1d1d1f;
        }

        input:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.1);
        }

        input::placeholder {
            color: #86868b;
        }

        button {
            width: 100%;
            padding: 14px 24px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #0051D5;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #d2d2d7;
            color: #86868b;
            cursor: not-allowed;
            transform: none;
        }

        .video-container {
            position: relative;
            background: #000000;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        video {
            width: 100%;
            display: block;
            max-height: 500px;
        }

        .status {
            text-align: center;
            padding: 12px 16px;
            margin-top: 16px;
            border-radius: 10px;
            font-weight: 500;
            font-size: 0.95em;
        }

        .status.success {
            background: #e5f5ea;
            color: #1e7b34;
        }

        .status.error {
            background: #ffe5e5;
            color: #d32f2f;
        }

        .status.info {
            background: #e5f2ff;
            color: #007AFF;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f5f5f7;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #86868b;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #007AFF;
        }

        .copy-btn {
            display: inline-block;
            padding: 8px 16px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #0051D5;
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .qr-section {
            margin-top: 24px;
            text-align: center;
        }

        .qr-title {
            font-size: 0.95em;
            color: #1d1d1f;
            font-weight: 500;
            margin-bottom: 12px;
        }

        #qrcode {
            display: inline-block;
            padding: 16px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #qrcode canvas {
            border-radius: 8px;
        }

        .qr-instruction {
            margin-top: 12px;
            font-size: 0.85em;
            color: #86868b;
        }

        .quality-selector {
            margin-bottom: 20px;
        }

        select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 10px;
            font-size: 1em;
            background: #ffffff;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.1);
        }

        .chart-section {
            margin-top: 32px;
            padding-top: 32px;
            border-top: 1px solid #d2d2d7;
        }

        .chart-title {
            font-size: 1.1em;
            color: #1d1d1f;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .chart-container {
            position: relative;
            height: 250px;
            background: #f5f5f7;
            border-radius: 12px;
            padding: 16px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 24px;
            }

            h1 {
                font-size: 2em;
            }

            .mode-selector {
                flex-direction: row;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“¹ WebRTC Webcam Streaming</h1>
        <p class="subtitle">Ultra Low Latency P2P Video Streaming</p>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('broadcast')">ðŸ“¡ Broadcast</button>
            <button class="mode-btn" onclick="setMode('viewer')">ðŸ‘€ Watch</button>
        </div>

        <!-- Broadcast Panel -->
        <div id="broadcast-panel" class="panel active">
            <div class="info-box">
                <strong>Broadcast Mode:</strong> Share your webcam with others.
            </div>

            <div class="quality-selector">
                <label>Resolution Settings</label>
                <select id="resolutionSelect">
                    <option value="640x480">SD - 640x480</option>
                    <option value="1280x720">HD - 1280x720</option>
                    <option value="1920x1080" selected>Full HD - 1920x1080</option>
                    <option value="2560x1440">2K - 2560x1440</option>
                    <option value="3840x2160">4K - 3840x2160</option>
                </select>
            </div>

            <div class="quality-selector">
                <label>Signaling Method</label>
                <select id="signalingMode" onchange="updateSignalingUI()">
                    <option value="peerjs">PeerJS (Auto - may be unstable)</option>
                    <option value="manual" selected>Manual (Copy-Paste - 100% stable)</option>
                </select>
            </div>

            <div class="quality-selector">
                <label>Connection Mode</label>
                <select id="connectionMode">
                    <option value="p2p" selected>P2P (Internet - uses STUN)</option>
                    <option value="lan">LAN Only (Local Network)</option>
                </select>
            </div>

            <div class="quality-selector">
                <label>Max Bitrate (Mbps) - Higher = Better Quality</label>
                <select id="bitrateLimit">
                    <option value="1000">1 Mbps (Low)</option>
                    <option value="2500">2.5 Mbps (Medium)</option>
                    <option value="5000">5 Mbps (High)</option>
                    <option value="10000" selected>10 Mbps (Very High)</option>
                    <option value="20000">20 Mbps (Ultra)</option>
                    <option value="0">Unlimited</option>
                </select>
            </div>

            <div id="peerjsOptions" class="quality-selector" style="display: none;">
                <label>PeerJS Server (for stability)</label>
                <input type="text" id="peerServer" placeholder="Leave empty for default (0.peerjs.com)" style="margin-bottom: 5px;">
                <small style="color: #86868b; font-size: 0.85em;">Custom server: your-server.com (no https://)</small>
            </div>

            <button id="startBroadcast" onclick="startBroadcast()">Start Webcam</button>

            <!-- Manual Signaling UI for Broadcaster -->
            <div id="manualBroadcastUI" style="display: none; margin-top: 20px;">
                <div class="info-box">
                    <strong>Step 1:</strong> Start webcam above<br>
                    <strong>Step 2:</strong> Copy "Offer" below and send to viewer<br>
                    <strong>Step 3:</strong> Paste viewer's "Answer" in the box below
                </div>

                <div class="input-group">
                    <label>Offer (Copy and send to viewer)</label>
                    <textarea id="manualOffer" readonly style="width: 100%; height: 100px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-family: monospace; font-size: 0.85em;"></textarea>
                    <button class="copy-btn" style="width: 100%; margin-top: 5px;" onclick="copyText('manualOffer')">Copy Offer</button>
                </div>

                <div class="input-group">
                    <label>Answer (Paste from viewer)</label>
                    <textarea id="manualAnswer" placeholder="Paste viewer's answer here..." style="width: 100%; height: 100px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-family: monospace; font-size: 0.85em;"></textarea>
                    <button onclick="setRemoteAnswer()" style="width: 100%; margin-top: 5px;">Connect to Viewer</button>
                </div>
            </div>

            <div id="broadcastInfo" style="display: none;">
                <div id="peerjsInfo" class="input-group">
                    <label>Share ID (Send this to viewers)</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="myPeerId" readonly>
                        <button class="copy-btn" onclick="copyPeerId()">Copy</button>
                    </div>
                </div>

                <div id="peerjsQR" class="qr-section">
                    <div class="qr-title">Share via QR Code</div>
                    <div id="qrcode"></div>
                    <div class="qr-instruction">Scan with smartphone to start watching</div>
                </div>

                <div class="video-container">
                    <video id="localVideo" autoplay muted playsinline></video>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Connected Viewers</div>
                        <div class="stat-value" id="viewerCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Resolution</div>
                        <div class="stat-value" id="txResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Frame Rate</div>
                        <div class="stat-value" id="txFps">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Bitrate</div>
                        <div class="stat-value" id="txBitrate">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Codec</div>
                        <div class="stat-value" id="txCodec">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packet Loss</div>
                        <div class="stat-value" id="txPacketLoss">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Network Type</div>
                        <div class="stat-value" id="txNetworkType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Transport</div>
                        <div class="stat-value" id="txTransport">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Local IP</div>
                        <div class="stat-value" id="txLocalIP">-</div>
                    </div>
                </div>

                <div class="chart-section">
                    <div class="chart-title">Real-time Performance Metrics</div>
                    <div class="chart-container">
                        <canvas id="broadcasterChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="broadcastStatus"></div>
        </div>

        <!-- Viewer Panel -->
        <div id="viewer-panel" class="panel">
            <div class="info-box">
                <strong>Watch Mode:</strong> Connect to broadcaster's stream.
            </div>

            <div class="quality-selector">
                <label>Signaling Method</label>
                <select id="viewerSignalingMode" onchange="updateViewerSignalingUI()">
                    <option value="peerjs">PeerJS (Auto - may be unstable)</option>
                    <option value="manual" selected>Manual (Copy-Paste - 100% stable)</option>
                </select>
            </div>

            <!-- PeerJS Mode -->
            <div id="peerjsViewerUI">
                <div class="input-group">
                    <label>Enter Broadcaster ID</label>
                    <input type="text" id="remotePeerId" placeholder="Enter the shared ID from broadcaster">
                </div>

                <button id="connectBtn" onclick="connectToStream()">Connect</button>
            </div>

            <!-- Manual Mode -->
            <div id="manualViewerUI" style="display: none;">
                <div class="info-box">
                    <strong>Step 1:</strong> Paste broadcaster's "Offer" below<br>
                    <strong>Step 2:</strong> Click "Generate Answer"<br>
                    <strong>Step 3:</strong> Copy "Answer" and send back to broadcaster
                </div>

                <div class="input-group">
                    <label>Offer (Paste from broadcaster)</label>
                    <textarea id="viewerOffer" placeholder="Paste broadcaster's offer here..." style="width: 100%; height: 100px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-family: monospace; font-size: 0.85em;"></textarea>
                    <button onclick="generateAnswer()" style="width: 100%; margin-top: 5px;">Generate Answer</button>
                </div>

                <div class="input-group">
                    <label>Answer (Copy and send to broadcaster)</label>
                    <textarea id="viewerAnswer" readonly style="width: 100%; height: 100px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-family: monospace; font-size: 0.85em;"></textarea>
                    <button class="copy-btn" style="width: 100%; margin-top: 5px;" onclick="copyText('viewerAnswer')">Copy Answer</button>
                </div>
            </div>

            <div id="remoteVideoContainer" style="display: none;">
                <div class="video-container">
                    <video id="remoteVideo" autoplay playsinline></video>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Resolution</div>
                        <div class="stat-value" id="rxResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Frame Rate</div>
                        <div class="stat-value" id="rxFps">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Bitrate</div>
                        <div class="stat-value" id="rxBitrate">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Latency (RTT)</div>
                        <div class="stat-value" id="rxLatency">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Jitter</div>
                        <div class="stat-value" id="rxJitter">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packet Loss</div>
                        <div class="stat-value" id="rxPacketLoss">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Network Type</div>
                        <div class="stat-value" id="rxNetworkType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Transport</div>
                        <div class="stat-value" id="rxTransport">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Remote IP</div>
                        <div class="stat-value" id="rxRemoteIP">-</div>
                    </div>
                </div>

                <div class="chart-section">
                    <div class="chart-title">Real-time Performance Metrics</div>
                    <div class="chart-container">
                        <canvas id="viewerChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="viewerStatus"></div>
        </div>
    </div>

    <!-- PeerJS CDN -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- QRCode.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        let peer = null;
        let localStream = null;
        let currentCall = null;
        let qrCodeInstance = null;
        const connections = new Set();
        let statsInterval = null;
        let lastBytesSent = 0;
        let lastBytesReceived = 0;
        let lastStatsTime = 0;

        // Manual WebRTC variables
        let manualPeerConnection = null;
        let pendingIceCandidates = [];
        let isManualMode = false;

        // Chart.js ì¸ìŠ¤í„´ìŠ¤
        let broadcasterChart = null;
        let viewerChart = null;

        // ê·¸ëž˜í”„ ë°ì´í„° (ìµœê·¼ 30ê°œ ìœ ì§€)
        const maxDataPoints = 30;
        const chartData = {
            broadcaster: {
                labels: [],
                fps: [],
                bitrate: [],
                packetLoss: []
            },
            viewer: {
                labels: [],
                fps: [],
                bitrate: [],
                latency: [],
                jitter: [],
                packetLoss: []
            }
        };

        // ì†¡ì¶œìž ê·¸ëž˜í”„ ì´ˆê¸°í™”
        function initBroadcasterChart() {
            const ctx = document.getElementById('broadcasterChart').getContext('2d');
            broadcasterChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'FPS',
                            data: [],
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'ë¹„íŠ¸ë ˆì´íŠ¸ (kbps)',
                            data: [],
                            borderColor: '#34C759',
                            backgroundColor: 'rgba(52, 199, 89, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'íŒ¨í‚· ì†ì‹¤ (%)',
                            data: [],
                            borderColor: '#FF3B30',
                            backgroundColor: 'rgba(255, 59, 48, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'FPS'
                            },
                            min: 0,
                            max: 60
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Bitrate (kbps)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            min: 0
                        },
                        y2: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 10
                        }
                    }
                }
            });
        }

        // ì‹œì²­ìž ê·¸ëž˜í”„ ì´ˆê¸°í™”
        function initViewerChart() {
            const ctx = document.getElementById('viewerChart').getContext('2d');
            viewerChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'FPS',
                            data: [],
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Bitrate (kbps)',
                            data: [],
                            borderColor: '#34C759',
                            backgroundColor: 'rgba(52, 199, 89, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Latency (ms)',
                            data: [],
                            borderColor: '#FF9500',
                            backgroundColor: 'rgba(255, 149, 0, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Jitter (ms)',
                            data: [],
                            borderColor: '#AF52DE',
                            backgroundColor: 'rgba(175, 82, 222, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y4'
                        },
                        {
                            label: 'Packet Loss (%)',
                            data: [],
                            borderColor: '#FF3B30',
                            backgroundColor: 'rgba(255, 59, 48, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y3'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'FPS'
                            },
                            min: 0,
                            max: 60
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Bitrate (kbps)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            min: 0
                        },
                        y2: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 500
                        },
                        y3: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 10
                        },
                        y4: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 50
                        }
                    }
                }
            });
        }

        // ê·¸ëž˜í”„ ë°ì´í„° ì—…ë°ì´íŠ¸
        function updateChartData(isBroadcaster, fps, bitrate, latency, jitter, packetLoss) {
            const now = new Date().toLocaleTimeString();
            const data = isBroadcaster ? chartData.broadcaster : chartData.viewer;
            const chart = isBroadcaster ? broadcasterChart : viewerChart;

            // ë ˆì´ë¸” ì¶”ê°€
            data.labels.push(now);
            if (data.labels.length > maxDataPoints) {
                data.labels.shift();
            }

            // FPS ë°ì´í„°
            data.fps.push(fps || 0);
            if (data.fps.length > maxDataPoints) {
                data.fps.shift();
            }

            // ë¹„íŠ¸ë ˆì´íŠ¸ ë°ì´í„°
            data.bitrate.push(bitrate || 0);
            if (data.bitrate.length > maxDataPoints) {
                data.bitrate.shift();
            }

            // ë ˆì´í„´ì‹œ (ì‹œì²­ìžë§Œ)
            if (!isBroadcaster) {
                data.latency.push(latency || 0);
                if (data.latency.length > maxDataPoints) {
                    data.latency.shift();
                }

                // Jitter (ì‹œì²­ìžë§Œ)
                data.jitter.push(jitter || 0);
                if (data.jitter.length > maxDataPoints) {
                    data.jitter.shift();
                }
            }

            // íŒ¨í‚· ì†ì‹¤
            data.packetLoss.push(packetLoss || 0);
            if (data.packetLoss.length > maxDataPoints) {
                data.packetLoss.shift();
            }

            // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            if (chart) {
                chart.data.labels = data.labels;
                chart.data.datasets[0].data = data.fps;
                chart.data.datasets[1].data = data.bitrate;
                if (isBroadcaster) {
                    chart.data.datasets[2].data = data.packetLoss;
                } else {
                    chart.data.datasets[2].data = data.latency;
                    chart.data.datasets[3].data = data.jitter;
                    chart.data.datasets[4].data = data.packetLoss;
                }
                chart.update('none'); // ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì—…ë°ì´íŠ¸
            }
        }

        // ì†¡ì¶œìž í†µê³„ ì—…ë°ì´íŠ¸
        async function updateBroadcasterStats() {
            if (!currentCall && connections.size === 0) return;

            try {
                // ì²« ë²ˆì§¸ ì—°ê²°ì˜ peerConnection ê°€ì ¸ì˜¤ê¸°
                const conn = Array.from(connections)[0];
                if (!conn || !conn.peerConnection) return;

                const stats = await conn.peerConnection.getStats();
                const now = Date.now();

                let currentFps = 0;
                let currentBitrate = 0;
                let currentPacketLoss = 0;

                stats.forEach(report => {
                    // ì†¡ì‹  ë¹„ë””ì˜¤ íŠ¸ëž™ ì •ë³´
                    if (report.type === 'outbound-rtp' && report.kind === 'video') {
                        // í•´ìƒë„
                        if (report.frameWidth && report.frameHeight) {
                            document.getElementById('txResolution').textContent =
                                `${report.frameWidth}x${report.frameHeight}`;
                        }

                        // í”„ë ˆìž„ë ˆì´íŠ¸
                        if (report.framesPerSecond) {
                            currentFps = Math.round(report.framesPerSecond);
                            document.getElementById('txFps').textContent = `${currentFps} fps`;
                        }

                        // ë¹„íŠ¸ë ˆì´íŠ¸ ê³„ì‚°
                        if (report.bytesSent && lastBytesSent > 0 && lastStatsTime > 0) {
                            const bytesDiff = report.bytesSent - lastBytesSent;
                            const timeDiff = (now - lastStatsTime) / 1000;
                            currentBitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // kbps
                            document.getElementById('txBitrate').textContent = `${currentBitrate} kbps`;
                        }
                        lastBytesSent = report.bytesSent;
                    }

                    // ì½”ë± ì •ë³´
                    if (report.type === 'codec' && report.mimeType && report.mimeType.includes('video')) {
                        const codecName = report.mimeType.split('/')[1].toUpperCase();
                        document.getElementById('txCodec').textContent = codecName;
                    }

                    // ì›ê²© ìˆ˜ì‹  í†µê³„ (íŒ¨í‚· ì†ì‹¤)
                    if (report.type === 'remote-inbound-rtp' && report.kind === 'video') {
                        if (report.packetsLost !== undefined && report.packetsReceived !== undefined) {
                            const total = report.packetsLost + report.packetsReceived;
                            const lossRate = total > 0 ? (report.packetsLost / total * 100) : 0;
                            currentPacketLoss = parseFloat(lossRate.toFixed(2));
                            document.getElementById('txPacketLoss').textContent = `${currentPacketLoss}%`;
                        }
                    }

                    // ICE candidate pair (ë„¤íŠ¸ì›Œí¬ ì •ë³´)
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        // Local candidate
                        const localCandidateId = report.localCandidateId;
                        stats.forEach(r => {
                            if (r.id === localCandidateId && r.type === 'local-candidate') {
                                document.getElementById('txLocalIP').textContent = r.address || r.ip || '-';
                                document.getElementById('txNetworkType').textContent = r.networkType || r.candidateType || '-';
                                document.getElementById('txTransport').textContent = r.protocol ? r.protocol.toUpperCase() : '-';
                            }
                        });
                    }
                });

                // ê·¸ëž˜í”„ ì—…ë°ì´íŠ¸
                updateChartData(true, currentFps, currentBitrate, 0, 0, currentPacketLoss);

                lastStatsTime = now;
            } catch (err) {
                console.error('Stats update failed:', err);
            }
        }

        // ì‹œì²­ìž í†µê³„ ì—…ë°ì´íŠ¸
        async function updateViewerStats() {
            if (!currentCall || !currentCall.peerConnection) return;

            try {
                const stats = await currentCall.peerConnection.getStats();
                const now = Date.now();

                let currentFps = 0;
                let currentBitrate = 0;
                let currentLatency = 0;
                let currentJitter = 0;
                let currentPacketLoss = 0;

                stats.forEach(report => {
                    // ìˆ˜ì‹  ë¹„ë””ì˜¤ íŠ¸ëž™ ì •ë³´
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        // í•´ìƒë„
                        if (report.frameWidth && report.frameHeight) {
                            document.getElementById('rxResolution').textContent =
                                `${report.frameWidth}x${report.frameHeight}`;
                        }

                        // í”„ë ˆìž„ë ˆì´íŠ¸
                        if (report.framesPerSecond) {
                            currentFps = Math.round(report.framesPerSecond);
                            document.getElementById('rxFps').textContent = `${currentFps} fps`;
                        }

                        // ë¹„íŠ¸ë ˆì´íŠ¸ ê³„ì‚°
                        if (report.bytesReceived && lastBytesReceived > 0 && lastStatsTime > 0) {
                            const bytesDiff = report.bytesReceived - lastBytesReceived;
                            const timeDiff = (now - lastStatsTime) / 1000;
                            currentBitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // kbps
                            document.getElementById('rxBitrate').textContent = `${currentBitrate} kbps`;
                        }
                        lastBytesReceived = report.bytesReceived;

                        // ì§€í„°
                        if (report.jitter !== undefined) {
                            currentJitter = parseFloat((report.jitter * 1000).toFixed(1));
                            document.getElementById('rxJitter').textContent = `${currentJitter} ms`;
                        }

                        // íŒ¨í‚· ì†ì‹¤
                        if (report.packetsLost !== undefined && report.packetsReceived !== undefined) {
                            const total = report.packetsLost + report.packetsReceived;
                            const lossRate = total > 0 ? (report.packetsLost / total * 100) : 0;
                            currentPacketLoss = parseFloat(lossRate.toFixed(2));
                            document.getElementById('rxPacketLoss').textContent = `${currentPacketLoss}%`;
                        }

                        // ë ˆì´í„´ì‹œ (jitterBufferDelay)
                        if (report.jitterBufferDelay !== undefined && report.jitterBufferEmittedCount > 0) {
                            currentLatency = Math.round((report.jitterBufferDelay / report.jitterBufferEmittedCount) * 1000);
                            document.getElementById('rxLatency').textContent = `${currentLatency} ms`;
                        }
                    }

                    // ICE í›„ë³´ ìŒì—ì„œ RTT (Round Trip Time) ê°€ì ¸ì˜¤ê¸°
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        if (report.currentRoundTripTime !== undefined) {
                            currentLatency = Math.round(report.currentRoundTripTime * 1000);
                            document.getElementById('rxLatency').textContent = `${currentLatency} ms`;
                        }

                        // Remote candidate (broadcaster's IP)
                        const remoteCandidateId = report.remoteCandidateId;
                        stats.forEach(r => {
                            if (r.id === remoteCandidateId && r.type === 'remote-candidate') {
                                document.getElementById('rxRemoteIP').textContent = r.address || r.ip || '-';
                                document.getElementById('rxNetworkType').textContent = r.networkType || r.candidateType || '-';
                                document.getElementById('rxTransport').textContent = r.protocol ? r.protocol.toUpperCase() : '-';
                            }
                        });
                    }
                });

                // ê·¸ëž˜í”„ ì—…ë°ì´íŠ¸
                updateChartData(false, currentFps, currentBitrate, currentLatency, currentJitter, currentPacketLoss);

                lastStatsTime = now;
            } catch (err) {
                console.error('Stats update failed:', err);
            }
        }

        // í†µê³„ ì—…ë°ì´íŠ¸ ì‹œìž‘
        function startStatsMonitoring(isBroadcaster) {
            // ê¸°ì¡´ ì¸í„°ë²Œ ì •ë¦¬
            if (statsInterval) {
                clearInterval(statsInterval);
            }

            // ê·¸ëž˜í”„ ì´ˆê¸°í™”
            if (isBroadcaster) {
                if (!broadcasterChart) {
                    initBroadcasterChart();
                }
            } else {
                if (!viewerChart) {
                    initViewerChart();
                }
            }

            // 1ì´ˆë§ˆë‹¤ í†µê³„ ì—…ë°ì´íŠ¸
            statsInterval = setInterval(() => {
                if (isBroadcaster) {
                    updateBroadcasterStats();
                } else {
                    updateViewerStats();
                }
            }, 1000);
        }

        // í†µê³„ ì—…ë°ì´íŠ¸ ì¤‘ì§€
        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            lastBytesSent = 0;
            lastBytesReceived = 0;
            lastStatsTime = 0;

            // ê·¸ëž˜í”„ ë°ì´í„° ì´ˆê¸°í™”
            chartData.broadcaster.labels = [];
            chartData.broadcaster.fps = [];
            chartData.broadcaster.bitrate = [];
            chartData.broadcaster.packetLoss = [];
            chartData.viewer.labels = [];
            chartData.viewer.fps = [];
            chartData.viewer.bitrate = [];
            chartData.viewer.latency = [];
            chartData.viewer.jitter = [];
            chartData.viewer.packetLoss = [];
        }

        // Signaling UI ì—…ë°ì´íŠ¸ (Broadcaster)
        function updateSignalingUI() {
            const mode = document.getElementById('signalingMode').value;
            isManualMode = (mode === 'manual');

            if (isManualMode) {
                document.getElementById('peerjsOptions').style.display = 'none';
                document.getElementById('manualBroadcastUI').style.display = 'block';
                // Hide PeerJS-specific info when in broadcast
                if (document.getElementById('broadcastInfo').style.display !== 'none') {
                    document.getElementById('peerjsInfo').style.display = 'none';
                    document.getElementById('peerjsQR').style.display = 'none';
                }
            } else {
                document.getElementById('peerjsOptions').style.display = 'block';
                document.getElementById('manualBroadcastUI').style.display = 'none';
                if (document.getElementById('broadcastInfo').style.display !== 'none') {
                    document.getElementById('peerjsInfo').style.display = 'block';
                    document.getElementById('peerjsQR').style.display = 'block';
                }
            }
        }

        // Signaling UI ì—…ë°ì´íŠ¸ (Viewer)
        function updateViewerSignalingUI() {
            const mode = document.getElementById('viewerSignalingMode').value;

            if (mode === 'manual') {
                document.getElementById('peerjsViewerUI').style.display = 'none';
                document.getElementById('manualViewerUI').style.display = 'block';
            } else {
                document.getElementById('peerjsViewerUI').style.display = 'block';
                document.getElementById('manualViewerUI').style.display = 'none';
            }
        }

        // í…ìŠ¤íŠ¸ ë³µì‚¬ í•¨ìˆ˜
        function copyText(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            element.setSelectionRange(0, 99999); // Mobile support

            // Determine which status to show based on element ID
            const statusId = elementId.includes('viewer') || elementId === 'viewerAnswer' ? 'viewerStatus' : 'broadcastStatus';

            try {
                document.execCommand('copy');
                showStatus(statusId, 'Copied to clipboard!', 'success');
                setTimeout(() => showStatus(statusId, '', 'info'), 2000);
            } catch (err) {
                // Fallback to navigator.clipboard
                navigator.clipboard.writeText(element.value).then(() => {
                    showStatus(statusId, 'Copied to clipboard!', 'success');
                    setTimeout(() => showStatus(statusId, '', 'info'), 2000);
                }).catch(() => {
                    showStatus(statusId, 'Failed to copy', 'error');
                });
            }
        }

        // Manual WebRTC: Broadcaster creates offer
        async function createManualOffer() {
            try {
                // Connection mode í™•ì¸
                const connectionMode = document.getElementById('connectionMode').value;
                const iceServers = connectionMode === 'lan' ? [] : [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ];

                const maxBitrate = parseInt(document.getElementById('bitrateLimit').value);

                // Create peer connection
                manualPeerConnection = new RTCPeerConnection({
                    iceServers: iceServers
                });

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    manualPeerConnection.addTrack(track, localStream);
                });

                // Apply bitrate limit
                if (maxBitrate > 0) {
                    const senders = manualPeerConnection.getSenders();
                    senders.forEach(sender => {
                        if (sender.track && sender.track.kind === 'video') {
                            const parameters = sender.getParameters();
                            if (!parameters.encodings) {
                                parameters.encodings = [{}];
                            }
                            parameters.encodings[0].maxBitrate = maxBitrate * 1000;
                            sender.setParameters(parameters).catch(e => console.log('Bitrate limit failed:', e));
                        }
                    });
                }

                // Collect ICE candidates
                pendingIceCandidates = [];
                manualPeerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        pendingIceCandidates.push(event.candidate);
                    } else {
                        // All ICE candidates collected, generate final offer
                        const offer = {
                            type: manualPeerConnection.localDescription.type,
                            sdp: manualPeerConnection.localDescription.sdp,
                            candidates: pendingIceCandidates
                        };
                        document.getElementById('manualOffer').value = JSON.stringify(offer);
                        showStatus('broadcastStatus', 'Offer generated! Copy and send to viewer.', 'success');
                    }
                };

                // Monitor connection state
                manualPeerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', manualPeerConnection.connectionState);
                    if (manualPeerConnection.connectionState === 'connected') {
                        showStatus('broadcastStatus', 'Connected to viewer!', 'success');
                        connections.add({ peerConnection: manualPeerConnection });
                        updateViewerCount();
                        startStatsMonitoring(true);
                    } else if (manualPeerConnection.connectionState === 'failed' ||
                               manualPeerConnection.connectionState === 'disconnected') {
                        showStatus('broadcastStatus', 'Connection failed or disconnected', 'error');
                        connections.clear();
                        updateViewerCount();
                        stopStatsMonitoring();
                    }
                };

                // Create offer
                const offer = await manualPeerConnection.createOffer();
                await manualPeerConnection.setLocalDescription(offer);

                showStatus('broadcastStatus', 'Generating offer... (collecting ICE candidates)', 'info');

            } catch (err) {
                console.error('Error creating offer:', err);
                showStatus('broadcastStatus', 'Failed to create offer: ' + err.message, 'error');
            }
        }

        // Manual WebRTC: Broadcaster sets answer
        async function setRemoteAnswer() {
            try {
                const answerText = document.getElementById('manualAnswer').value.trim();
                if (!answerText) {
                    showStatus('broadcastStatus', 'Please paste viewer\'s answer', 'error');
                    return;
                }

                const answerData = JSON.parse(answerText);

                // Set remote description
                await manualPeerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: answerData.type,
                    sdp: answerData.sdp
                }));

                // Add ICE candidates
                for (const candidate of answerData.candidates) {
                    await manualPeerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }

                showStatus('broadcastStatus', 'Answer set! Connecting...', 'info');

            } catch (err) {
                console.error('Error setting answer:', err);
                showStatus('broadcastStatus', 'Failed to set answer: ' + err.message, 'error');
            }
        }

        // Manual WebRTC: Viewer generates answer
        async function generateAnswer() {
            try {
                const offerText = document.getElementById('viewerOffer').value.trim();
                if (!offerText) {
                    showStatus('viewerStatus', 'Please paste broadcaster\'s offer', 'error');
                    return;
                }

                showStatus('viewerStatus', 'Processing offer...', 'info');

                const offerData = JSON.parse(offerText);

                // Create peer connection
                manualPeerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // Handle incoming stream
                manualPeerConnection.ontrack = (event) => {
                    console.log('Remote track received:', event.streams[0]);
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                    document.getElementById('remoteVideoContainer').style.display = 'block';
                    showStatus('viewerStatus', 'Streaming!', 'success');
                    startStatsMonitoring(false);
                };

                // Monitor connection state
                manualPeerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', manualPeerConnection.connectionState);
                    if (manualPeerConnection.connectionState === 'connected') {
                        showStatus('viewerStatus', 'Connected!', 'success');
                    } else if (manualPeerConnection.connectionState === 'failed' ||
                               manualPeerConnection.connectionState === 'disconnected') {
                        showStatus('viewerStatus', 'Connection failed or disconnected', 'error');
                        document.getElementById('remoteVideoContainer').style.display = 'none';
                        stopStatsMonitoring();
                    }
                };

                // Store as currentCall for stats monitoring compatibility
                currentCall = { peerConnection: manualPeerConnection };

                // Set remote description
                await manualPeerConnection.setRemoteDescription(new RTCSessionDescription({
                    type: offerData.type,
                    sdp: offerData.sdp
                }));

                // Add ICE candidates from offer
                for (const candidate of offerData.candidates) {
                    await manualPeerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }

                // Create answer
                const answer = await manualPeerConnection.createAnswer();
                await manualPeerConnection.setLocalDescription(answer);

                // Collect ICE candidates for answer
                pendingIceCandidates = [];
                manualPeerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        pendingIceCandidates.push(event.candidate);
                    } else {
                        // All ICE candidates collected, generate final answer
                        const answerData = {
                            type: manualPeerConnection.localDescription.type,
                            sdp: manualPeerConnection.localDescription.sdp,
                            candidates: pendingIceCandidates
                        };
                        document.getElementById('viewerAnswer').value = JSON.stringify(answerData);
                        showStatus('viewerStatus', 'Answer generated! Copy and send to broadcaster.', 'success');
                    }
                };

                showStatus('viewerStatus', 'Generating answer... (collecting ICE candidates)', 'info');

            } catch (err) {
                console.error('Error generating answer:', err);
                showStatus('viewerStatus', 'Failed to generate answer: ' + err.message, 'error');
            }
        }

        // íŽ˜ì´ì§€ ë¡œë“œ ì‹œ URL íŒŒë¼ë¯¸í„° ì²´í¬
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize UI based on default signaling mode
            updateSignalingUI();
            updateViewerSignalingUI();
            const urlParams = new URLSearchParams(window.location.search);
            const peerId = urlParams.get('id');

            if (peerId) {
                // QR ì½”ë“œë¡œ ì ‘ì†í•œ ê²½ìš° ìžë™ìœ¼ë¡œ ì‹œì²­ ëª¨ë“œë¡œ ì „í™˜
                setMode('viewer');
                document.getElementById('remotePeerId').value = peerId;
                // 1ì´ˆ í›„ ìžë™ ì—°ê²° (íŽ˜ì´ì§€ ë¡œë”© ì™„ë£Œ ëŒ€ê¸°)
                setTimeout(() => {
                    connectToStream();
                }, 1000);
            }
        });

        // ëª¨ë“œ ì „í™˜
        function setMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));

            if (mode === 'broadcast') {
                document.querySelector('.mode-btn:nth-child(1)').classList.add('active');
                document.getElementById('broadcast-panel').classList.add('active');
            } else {
                document.querySelector('.mode-btn:nth-child(2)').classList.add('active');
                document.getElementById('viewer-panel').classList.add('active');
            }

            // ì´ì „ ì—°ê²° ì •ë¦¬
            cleanup();
        }

        // ì†¡ì¶œ ì‹œìž‘
        async function startBroadcast() {
            try {
                showStatus('broadcastStatus', 'Accessing webcam...', 'info');

                // ì„ íƒí•œ í•´ìƒë„ ê°€ì ¸ì˜¤ê¸°
                const selectedResolution = document.getElementById('resolutionSelect').value;
                const [width, height] = selectedResolution.split('x').map(Number);

                // ì›¹ìº  ìŠ¤íŠ¸ë¦¼ íšë“
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: width },
                        height: { ideal: height },
                        frameRate: { ideal: 30 }
                    },
                    audio: true
                });

                // ë¡œì»¬ ë¹„ë””ì˜¤ í‘œì‹œ
                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('broadcastInfo').style.display = 'block';
                document.getElementById('startBroadcast').style.display = 'none';

                // Check if manual mode
                if (isManualMode) {
                    // Show video container but hide PeerJS-specific elements
                    document.getElementById('peerjsInfo').style.display = 'none';
                    document.getElementById('peerjsQR').style.display = 'none';
                    // Create manual offer
                    createManualOffer();
                    return;
                }

                // Connection mode í™•ì¸
                const connectionMode = document.getElementById('connectionMode').value;
                const iceServers = connectionMode === 'lan' ? [] : [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ];

                // ë¹„íŠ¸ë ˆì´íŠ¸ ì œí•œ ê°€ì ¸ì˜¤ê¸°
                const maxBitrate = parseInt(document.getElementById('bitrateLimit').value);

                // ì»¤ìŠ¤í…€ PeerJS ì„œë²„ ì„¤ì •
                const customServer = document.getElementById('peerServer').value.trim();
                const peerConfig = {
                    config: {
                        iceServers: iceServers,
                        iceTransportPolicy: connectionMode === 'lan' ? 'all' : 'all'
                    }
                };

                // ì»¤ìŠ¤í…€ ì„œë²„ê°€ ìžˆìœ¼ë©´ ì¶”ê°€
                if (customServer) {
                    peerConfig.host = customServer;
                    peerConfig.port = 443;
                    peerConfig.path = '/';
                    peerConfig.secure = true;
                }

                // Peer ì´ˆê¸°í™”
                peer = new Peer(peerConfig);

                peer.on('open', (id) => {
                    document.getElementById('myPeerId').value = id;

                    // QR ì½”ë“œ ìƒì„±
                    const qrUrl = `https://hwkim3330.github.io/cam/?id=${id}`;
                    const qrContainer = document.getElementById('qrcode');

                    // ê¸°ì¡´ QR ì½”ë“œ ì œê±°
                    qrContainer.innerHTML = '';

                    // ìƒˆ QR ì½”ë“œ ìƒì„±
                    qrCodeInstance = new QRCode(qrContainer, {
                        text: qrUrl,
                        width: 200,
                        height: 200,
                        colorDark: "#1d1d1f",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });

                    showStatus('broadcastStatus', 'Broadcast ready! Share your ID.', 'success');
                });

                peer.on('call', (call) => {
                    // ì‹œì²­ìžì˜ ì—°ê²° ìˆ˜ë½ with bitrate limit
                    call.answer(localStream);
                    connections.add(call);
                    updateViewerCount();

                    // ë¹„íŠ¸ë ˆì´íŠ¸ ì œí•œ ì ìš©
                    if (maxBitrate > 0 && call.peerConnection) {
                        const pc = call.peerConnection;
                        const senders = pc.getSenders();
                        senders.forEach(sender => {
                            if (sender.track && sender.track.kind === 'video') {
                                const parameters = sender.getParameters();
                                if (!parameters.encodings) {
                                    parameters.encodings = [{}];
                                }
                                parameters.encodings[0].maxBitrate = maxBitrate * 1000; // kbps to bps
                                sender.setParameters(parameters).catch(e => console.log('Bitrate limit failed:', e));
                            }
                        });
                    }

                    // í†µê³„ ëª¨ë‹ˆí„°ë§ ì‹œìž‘
                    if (connections.size === 1) {
                        startStatsMonitoring(true);
                    }

                    call.on('close', () => {
                        connections.delete(call);
                        updateViewerCount();

                        // ëª¨ë“  ì—°ê²°ì´ ëŠì–´ì§€ë©´ í†µê³„ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
                        if (connections.size === 0) {
                            stopStatsMonitoring();
                        }
                    });

                    showStatus('broadcastStatus', 'Viewer connected!', 'success');
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    if (err.type === 'network' || err.type === 'server-error') {
                        showStatus('broadcastStatus', 'Connection error. Check PeerJS server or try custom server.', 'error');
                    } else if (err.type === 'unavailable-id') {
                        showStatus('broadcastStatus', 'ID already in use. Refresh page to get new ID.', 'error');
                    } else {
                        showStatus('broadcastStatus', 'Error: ' + err.message + ' (Try custom PeerJS server)', 'error');
                    }
                });

            } catch (err) {
                showStatus('broadcastStatus', 'Webcam access failed: ' + err.message, 'error');
            }
        }

        // ìŠ¤íŠ¸ë¦¼ ì—°ê²° (ì‹œì²­ìž)
        async function connectToStream() {
            const remotePeerId = document.getElementById('remotePeerId').value.trim();

            if (!remotePeerId) {
                showStatus('viewerStatus', 'Please enter ID', 'error');
                return;
            }

            try {
                showStatus('viewerStatus', 'Connecting...', 'info');
                document.getElementById('connectBtn').disabled = true;

                // ë”ë¯¸ ìŠ¤íŠ¸ë¦¼ ìƒì„± (WebRTC ì—°ê²°ì„ ìœ„í•´ í•„ìš”)
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const dummyStream = canvas.captureStream(1); // 1fps ë”ë¯¸ ìŠ¤íŠ¸ë¦¼

                // ë”ë¯¸ ì˜¤ë””ì˜¤ íŠ¸ëž™ ì¶”ê°€
                const audioContext = new AudioContext();
                const oscillator = audioContext.createOscillator();
                const dst = oscillator.connect(audioContext.createMediaStreamDestination());
                oscillator.start();
                dummyStream.addTrack(dst.stream.getAudioTracks()[0]);

                // Peer ì´ˆê¸°í™”
                peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                peer.on('open', () => {
                    // ì†¡ì¶œìžì—ê²Œ ì—°ê²° (ë”ë¯¸ ìŠ¤íŠ¸ë¦¼ ì „ì†¡)
                    currentCall = peer.call(remotePeerId, dummyStream);

                    currentCall.on('stream', (remoteStream) => {
                        console.log('Stream received:', remoteStream);
                        document.getElementById('remoteVideo').srcObject = remoteStream;
                        document.getElementById('remoteVideoContainer').style.display = 'block';
                        showStatus('viewerStatus', 'Streaming!', 'success');
                        document.getElementById('connectBtn').disabled = false;

                        // í†µê³„ ëª¨ë‹ˆí„°ë§ ì‹œìž‘
                        startStatsMonitoring(false);
                    });

                    currentCall.on('close', () => {
                        showStatus('viewerStatus', 'Connection closed', 'error');
                        document.getElementById('remoteVideoContainer').style.display = 'none';
                        document.getElementById('connectBtn').disabled = false;

                        // í†µê³„ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
                        stopStatsMonitoring();
                    });

                    currentCall.on('error', (err) => {
                        console.error('Call Error:', err);
                        showStatus('viewerStatus', 'ì—°ê²° Error: ' + err.message, 'error');
                        document.getElementById('connectBtn').disabled = false;

                        // í†µê³„ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
                        stopStatsMonitoring();
                    });
                });

                peer.on('error', (err) => {
                    console.error('Peer Error:', err);
                    showStatus('viewerStatus', 'Error: ' + err.message, 'error');
                    document.getElementById('connectBtn').disabled = false;
                });

            } catch (err) {
                console.error('Connection failed:', err);
                showStatus('viewerStatus', 'Connection failed: ' + err.message, 'error');
                document.getElementById('connectBtn').disabled = false;
            }
        }

        // ID ë³µì‚¬
        function copyPeerId() {
            const peerIdInput = document.getElementById('myPeerId');
            peerIdInput.select();
            document.execCommand('copy');

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ“ Copied';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        // ì‹œì²­ìž ìˆ˜ ì—…ë°ì´íŠ¸
        function updateViewerCount() {
            document.getElementById('viewerCount').textContent = connections.size;
        }

        // ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
        function showStatus(elementId, message, type) {
            const statusEl = document.getElementById(elementId);
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // ì •ë¦¬
        function cleanup() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            if (currentCall) {
                currentCall.close();
                currentCall = null;
            }
            if (manualPeerConnection) {
                manualPeerConnection.close();
                manualPeerConnection = null;
            }
            connections.clear();
            pendingIceCandidates = [];

            // QR ì½”ë“œ ì´ˆê¸°í™”
            const qrContainer = document.getElementById('qrcode');
            if (qrContainer) {
                qrContainer.innerHTML = '';
            }
            qrCodeInstance = null;

            // í†µê³„ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
            stopStatsMonitoring();
        }

        // íŽ˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬
        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
