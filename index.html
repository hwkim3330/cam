<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Webcam Streaming - Ultra Low Latency</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Helvetica Neue", sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 4px 12px rgba(0,0,0,0.05);
            max-width: 800px;
            width: 100%;
            padding: 48px;
        }

        h1 {
            text-align: center;
            color: #1d1d1f;
            margin-bottom: 8px;
            font-size: 2.5em;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .subtitle {
            text-align: center;
            color: #86868b;
            margin-bottom: 40px;
            font-size: 1em;
            font-weight: 400;
        }

        .mode-selector {
            display: inline-flex;
            background: #f5f5f7;
            border-radius: 10px;
            padding: 2px;
            margin: 0 auto 40px;
            width: 100%;
            max-width: 400px;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
        }

        .mode-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #1d1d1f;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
        }

        .mode-btn:hover {
            color: #007AFF;
        }

        .mode-btn.active {
            background: #ffffff;
            color: #007AFF;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.05);
        }

        .panel {
            display: none;
        }

        .panel.active {
            display: block;
        }

        .info-box {
            background: #f5f5f7;
            border-left: 3px solid #007AFF;
            padding: 16px 20px;
            margin-bottom: 24px;
            border-radius: 8px;
        }

        .info-box strong {
            color: #007AFF;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #1d1d1f;
            font-weight: 500;
            font-size: 0.95em;
        }

        input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.2s;
            background: #ffffff;
            color: #1d1d1f;
        }

        input:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.1);
        }

        input::placeholder {
            color: #86868b;
        }

        button {
            width: 100%;
            padding: 14px 24px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #0051D5;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #d2d2d7;
            color: #86868b;
            cursor: not-allowed;
            transform: none;
        }

        .video-container {
            position: relative;
            background: #000000;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        video {
            width: 100%;
            display: block;
            max-height: 500px;
        }

        .status {
            text-align: center;
            padding: 12px 16px;
            margin-top: 16px;
            border-radius: 10px;
            font-weight: 500;
            font-size: 0.95em;
        }

        .status.success {
            background: #e5f5ea;
            color: #1e7b34;
        }

        .status.error {
            background: #ffe5e5;
            color: #d32f2f;
        }

        .status.info {
            background: #e5f2ff;
            color: #007AFF;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f5f5f7;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85em;
            color: #86868b;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #007AFF;
        }

        .copy-btn {
            display: inline-block;
            padding: 8px 16px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #0051D5;
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .qr-section {
            margin-top: 24px;
            text-align: center;
        }

        .qr-title {
            font-size: 0.95em;
            color: #1d1d1f;
            font-weight: 500;
            margin-bottom: 12px;
        }

        #qrcode {
            display: inline-block;
            padding: 16px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #qrcode canvas {
            border-radius: 8px;
        }

        .qr-instruction {
            margin-top: 12px;
            font-size: 0.85em;
            color: #86868b;
        }

        .quality-selector {
            margin-bottom: 20px;
        }

        select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d2d2d7;
            border-radius: 10px;
            font-size: 1em;
            background: #ffffff;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.1);
        }

        .chart-section {
            margin-top: 32px;
            padding-top: 32px;
            border-top: 1px solid #d2d2d7;
        }

        .chart-title {
            font-size: 1.1em;
            color: #1d1d1f;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .chart-container {
            position: relative;
            height: 250px;
            background: #f5f5f7;
            border-radius: 12px;
            padding: 16px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 24px;
            }

            h1 {
                font-size: 2em;
            }

            .mode-selector {
                flex-direction: row;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìπ WebRTC Webcam Streaming</h1>
        <p class="subtitle">Ultra Low Latency P2P Video Streaming</p>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('broadcast')">üì° Broadcast</button>
            <button class="mode-btn" onclick="setMode('viewer')">üëÄ Watch</button>
        </div>

        <!-- Broadcast Panel -->
        <div id="broadcast-panel" class="panel active">
            <div class="info-box">
                <strong>Broadcast Mode:</strong> Share your webcam with others. Click start and share your ID!
            </div>

            <button id="startBroadcast" onclick="startBroadcast()">Start Webcam</button>

            <div id="broadcastInfo" style="display: none;">
                <div class="input-group">
                    <label>Share ID (Send this to viewers)</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="myPeerId" readonly>
                        <button class="copy-btn" onclick="copyPeerId()">Copy</button>
                    </div>
                </div>

                <div class="qr-section">
                    <div class="qr-title">Share via QR Code</div>
                    <div id="qrcode"></div>
                    <div class="qr-instruction">Scan with smartphone to start watching</div>
                </div>

                <div class="video-container">
                    <video id="localVideo" autoplay muted playsinline></video>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Connected Viewers</div>
                        <div class="stat-value" id="viewerCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Resolution</div>
                        <div class="stat-value" id="txResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Frame Rate</div>
                        <div class="stat-value" id="txFps">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Bitrate</div>
                        <div class="stat-value" id="txBitrate">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Codec</div>
                        <div class="stat-value" id="txCodec">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packet Loss</div>
                        <div class="stat-value" id="txPacketLoss">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Network Type</div>
                        <div class="stat-value" id="txNetworkType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Transport</div>
                        <div class="stat-value" id="txTransport">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Local IP</div>
                        <div class="stat-value" id="txLocalIP">-</div>
                    </div>
                </div>

                <div class="chart-section">
                    <div class="chart-title">Real-time Performance Metrics</div>
                    <div class="chart-container">
                        <canvas id="broadcasterChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="broadcastStatus"></div>
        </div>

        <!-- Viewer Panel -->
        <div id="viewer-panel" class="panel">
            <div class="info-box">
                <strong>Watch Mode:</strong> Enter broadcaster's ID to watch the stream.
            </div>

            <div class="input-group">
                <label>Enter Broadcaster ID</label>
                <input type="text" id="remotePeerId" placeholder="Enter the shared ID from broadcaster">
            </div>

            <button id="connectBtn" onclick="connectToStream()">Connect</button>

            <div id="remoteVideoContainer" style="display: none;">
                <div class="video-container">
                    <video id="remoteVideo" autoplay playsinline></video>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Resolution</div>
                        <div class="stat-value" id="rxResolution">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Frame Rate</div>
                        <div class="stat-value" id="rxFps">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Bitrate</div>
                        <div class="stat-value" id="rxBitrate">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Latency (RTT)</div>
                        <div class="stat-value" id="rxLatency">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Jitter</div>
                        <div class="stat-value" id="rxJitter">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packet Loss</div>
                        <div class="stat-value" id="rxPacketLoss">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Network Type</div>
                        <div class="stat-value" id="rxNetworkType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Transport</div>
                        <div class="stat-value" id="rxTransport">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Remote IP</div>
                        <div class="stat-value" id="rxRemoteIP">-</div>
                    </div>
                </div>

                <div class="chart-section">
                    <div class="chart-title">Real-time Performance Metrics</div>
                    <div class="chart-container">
                        <canvas id="viewerChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="viewerStatus"></div>
        </div>
    </div>

    <!-- PeerJS CDN -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- QRCode.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        let peer = null;
        let localStream = null;
        let currentCall = null;
        let qrCodeInstance = null;
        const connections = new Set();
        let statsInterval = null;
        let lastBytesSent = 0;
        let lastBytesReceived = 0;
        let lastStatsTime = 0;

        // Chart.js Ïù∏Ïä§ÌÑ¥Ïä§
        let broadcasterChart = null;
        let viewerChart = null;

        // Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ (ÏµúÍ∑º 30Í∞ú Ïú†ÏßÄ)
        const maxDataPoints = 30;
        const chartData = {
            broadcaster: {
                labels: [],
                fps: [],
                bitrate: [],
                packetLoss: []
            },
            viewer: {
                labels: [],
                fps: [],
                bitrate: [],
                latency: [],
                jitter: [],
                packetLoss: []
            }
        };

        // ÏÜ°Ï∂úÏûê Í∑∏ÎûòÌîÑ Ï¥àÍ∏∞Ìôî
        function initBroadcasterChart() {
            const ctx = document.getElementById('broadcasterChart').getContext('2d');
            broadcasterChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'FPS',
                            data: [],
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'ÎπÑÌä∏Î†àÏù¥Ìä∏ (kbps)',
                            data: [],
                            borderColor: '#34C759',
                            backgroundColor: 'rgba(52, 199, 89, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Ìå®ÌÇ∑ ÏÜêÏã§ (%)',
                            data: [],
                            borderColor: '#FF3B30',
                            backgroundColor: 'rgba(255, 59, 48, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'FPS'
                            },
                            min: 0,
                            max: 60
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Bitrate (kbps)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            min: 0
                        },
                        y2: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 10
                        }
                    }
                }
            });
        }

        // ÏãúÏ≤≠Ïûê Í∑∏ÎûòÌîÑ Ï¥àÍ∏∞Ìôî
        function initViewerChart() {
            const ctx = document.getElementById('viewerChart').getContext('2d');
            viewerChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'FPS',
                            data: [],
                            borderColor: '#007AFF',
                            backgroundColor: 'rgba(0, 122, 255, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Bitrate (kbps)',
                            data: [],
                            borderColor: '#34C759',
                            backgroundColor: 'rgba(52, 199, 89, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Latency (ms)',
                            data: [],
                            borderColor: '#FF9500',
                            backgroundColor: 'rgba(255, 149, 0, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Jitter (ms)',
                            data: [],
                            borderColor: '#AF52DE',
                            backgroundColor: 'rgba(175, 82, 222, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y4'
                        },
                        {
                            label: 'Packet Loss (%)',
                            data: [],
                            borderColor: '#FF3B30',
                            backgroundColor: 'rgba(255, 59, 48, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y3'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'FPS'
                            },
                            min: 0,
                            max: 60
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Bitrate (kbps)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            min: 0
                        },
                        y2: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 500
                        },
                        y3: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 10
                        },
                        y4: {
                            type: 'linear',
                            display: false,
                            min: 0,
                            max: 50
                        }
                    }
                }
            });
        }

        // Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
        function updateChartData(isBroadcaster, fps, bitrate, latency, jitter, packetLoss) {
            const now = new Date().toLocaleTimeString();
            const data = isBroadcaster ? chartData.broadcaster : chartData.viewer;
            const chart = isBroadcaster ? broadcasterChart : viewerChart;

            // Î†àÏù¥Î∏î Ï∂îÍ∞Ä
            data.labels.push(now);
            if (data.labels.length > maxDataPoints) {
                data.labels.shift();
            }

            // FPS Îç∞Ïù¥ÌÑ∞
            data.fps.push(fps || 0);
            if (data.fps.length > maxDataPoints) {
                data.fps.shift();
            }

            // ÎπÑÌä∏Î†àÏù¥Ìä∏ Îç∞Ïù¥ÌÑ∞
            data.bitrate.push(bitrate || 0);
            if (data.bitrate.length > maxDataPoints) {
                data.bitrate.shift();
            }

            // Î†àÏù¥ÌÑ¥Ïãú (ÏãúÏ≤≠ÏûêÎßå)
            if (!isBroadcaster) {
                data.latency.push(latency || 0);
                if (data.latency.length > maxDataPoints) {
                    data.latency.shift();
                }

                // Jitter (ÏãúÏ≤≠ÏûêÎßå)
                data.jitter.push(jitter || 0);
                if (data.jitter.length > maxDataPoints) {
                    data.jitter.shift();
                }
            }

            // Ìå®ÌÇ∑ ÏÜêÏã§
            data.packetLoss.push(packetLoss || 0);
            if (data.packetLoss.length > maxDataPoints) {
                data.packetLoss.shift();
            }

            // Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            if (chart) {
                chart.data.labels = data.labels;
                chart.data.datasets[0].data = data.fps;
                chart.data.datasets[1].data = data.bitrate;
                if (isBroadcaster) {
                    chart.data.datasets[2].data = data.packetLoss;
                } else {
                    chart.data.datasets[2].data = data.latency;
                    chart.data.datasets[3].data = data.jitter;
                    chart.data.datasets[4].data = data.packetLoss;
                }
                chart.update('none'); // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏù¥ ÏóÖÎç∞Ïù¥Ìä∏
            }
        }

        // ÏÜ°Ï∂úÏûê ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        async function updateBroadcasterStats() {
            if (!currentCall && connections.size === 0) return;

            try {
                // Ï≤´ Î≤àÏß∏ Ïó∞Í≤∞Ïùò peerConnection Í∞ÄÏ†∏Ïò§Í∏∞
                const conn = Array.from(connections)[0];
                if (!conn || !conn.peerConnection) return;

                const stats = await conn.peerConnection.getStats();
                const now = Date.now();

                let currentFps = 0;
                let currentBitrate = 0;
                let currentPacketLoss = 0;

                stats.forEach(report => {
                    // ÏÜ°Ïã† ÎπÑÎîîÏò§ Ìä∏Îûô Ï†ïÎ≥¥
                    if (report.type === 'outbound-rtp' && report.kind === 'video') {
                        // Ìï¥ÏÉÅÎèÑ
                        if (report.frameWidth && report.frameHeight) {
                            document.getElementById('txResolution').textContent =
                                `${report.frameWidth}x${report.frameHeight}`;
                        }

                        // ÌîÑÎ†àÏûÑÎ†àÏù¥Ìä∏
                        if (report.framesPerSecond) {
                            currentFps = Math.round(report.framesPerSecond);
                            document.getElementById('txFps').textContent = `${currentFps} fps`;
                        }

                        // ÎπÑÌä∏Î†àÏù¥Ìä∏ Í≥ÑÏÇ∞
                        if (report.bytesSent && lastBytesSent > 0 && lastStatsTime > 0) {
                            const bytesDiff = report.bytesSent - lastBytesSent;
                            const timeDiff = (now - lastStatsTime) / 1000;
                            currentBitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // kbps
                            document.getElementById('txBitrate').textContent = `${currentBitrate} kbps`;
                        }
                        lastBytesSent = report.bytesSent;
                    }

                    // ÏΩîÎç± Ï†ïÎ≥¥
                    if (report.type === 'codec' && report.mimeType && report.mimeType.includes('video')) {
                        const codecName = report.mimeType.split('/')[1].toUpperCase();
                        document.getElementById('txCodec').textContent = codecName;
                    }

                    // ÏõêÍ≤© ÏàòÏã† ÌÜµÍ≥Ñ (Ìå®ÌÇ∑ ÏÜêÏã§)
                    if (report.type === 'remote-inbound-rtp' && report.kind === 'video') {
                        if (report.packetsLost !== undefined && report.packetsReceived !== undefined) {
                            const total = report.packetsLost + report.packetsReceived;
                            const lossRate = total > 0 ? (report.packetsLost / total * 100) : 0;
                            currentPacketLoss = parseFloat(lossRate.toFixed(2));
                            document.getElementById('txPacketLoss').textContent = `${currentPacketLoss}%`;
                        }
                    }

                    // ICE candidate pair (ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ≥¥)
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        // Local candidate
                        const localCandidateId = report.localCandidateId;
                        stats.forEach(r => {
                            if (r.id === localCandidateId && r.type === 'local-candidate') {
                                document.getElementById('txLocalIP').textContent = r.address || r.ip || '-';
                                document.getElementById('txNetworkType').textContent = r.networkType || r.candidateType || '-';
                                document.getElementById('txTransport').textContent = r.protocol ? r.protocol.toUpperCase() : '-';
                            }
                        });
                    }
                });

                // Í∑∏ÎûòÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
                updateChartData(true, currentFps, currentBitrate, 0, 0, currentPacketLoss);

                lastStatsTime = now;
            } catch (err) {
                console.error('Stats update failed:', err);
            }
        }

        // ÏãúÏ≤≠Ïûê ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        async function updateViewerStats() {
            if (!currentCall || !currentCall.peerConnection) return;

            try {
                const stats = await currentCall.peerConnection.getStats();
                const now = Date.now();

                let currentFps = 0;
                let currentBitrate = 0;
                let currentLatency = 0;
                let currentJitter = 0;
                let currentPacketLoss = 0;

                stats.forEach(report => {
                    // ÏàòÏã† ÎπÑÎîîÏò§ Ìä∏Îûô Ï†ïÎ≥¥
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        // Ìï¥ÏÉÅÎèÑ
                        if (report.frameWidth && report.frameHeight) {
                            document.getElementById('rxResolution').textContent =
                                `${report.frameWidth}x${report.frameHeight}`;
                        }

                        // ÌîÑÎ†àÏûÑÎ†àÏù¥Ìä∏
                        if (report.framesPerSecond) {
                            currentFps = Math.round(report.framesPerSecond);
                            document.getElementById('rxFps').textContent = `${currentFps} fps`;
                        }

                        // ÎπÑÌä∏Î†àÏù¥Ìä∏ Í≥ÑÏÇ∞
                        if (report.bytesReceived && lastBytesReceived > 0 && lastStatsTime > 0) {
                            const bytesDiff = report.bytesReceived - lastBytesReceived;
                            const timeDiff = (now - lastStatsTime) / 1000;
                            currentBitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // kbps
                            document.getElementById('rxBitrate').textContent = `${currentBitrate} kbps`;
                        }
                        lastBytesReceived = report.bytesReceived;

                        // ÏßÄÌÑ∞
                        if (report.jitter !== undefined) {
                            currentJitter = parseFloat((report.jitter * 1000).toFixed(1));
                            document.getElementById('rxJitter').textContent = `${currentJitter} ms`;
                        }

                        // Ìå®ÌÇ∑ ÏÜêÏã§
                        if (report.packetsLost !== undefined && report.packetsReceived !== undefined) {
                            const total = report.packetsLost + report.packetsReceived;
                            const lossRate = total > 0 ? (report.packetsLost / total * 100) : 0;
                            currentPacketLoss = parseFloat(lossRate.toFixed(2));
                            document.getElementById('rxPacketLoss').textContent = `${currentPacketLoss}%`;
                        }

                        // Î†àÏù¥ÌÑ¥Ïãú (jitterBufferDelay)
                        if (report.jitterBufferDelay !== undefined && report.jitterBufferEmittedCount > 0) {
                            currentLatency = Math.round((report.jitterBufferDelay / report.jitterBufferEmittedCount) * 1000);
                            document.getElementById('rxLatency').textContent = `${currentLatency} ms`;
                        }
                    }

                    // ICE ÌõÑÎ≥¥ ÏåçÏóêÏÑú RTT (Round Trip Time) Í∞ÄÏ†∏Ïò§Í∏∞
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        if (report.currentRoundTripTime !== undefined) {
                            currentLatency = Math.round(report.currentRoundTripTime * 1000);
                            document.getElementById('rxLatency').textContent = `${currentLatency} ms`;
                        }

                        // Remote candidate (broadcaster's IP)
                        const remoteCandidateId = report.remoteCandidateId;
                        stats.forEach(r => {
                            if (r.id === remoteCandidateId && r.type === 'remote-candidate') {
                                document.getElementById('rxRemoteIP').textContent = r.address || r.ip || '-';
                                document.getElementById('rxNetworkType').textContent = r.networkType || r.candidateType || '-';
                                document.getElementById('rxTransport').textContent = r.protocol ? r.protocol.toUpperCase() : '-';
                            }
                        });
                    }
                });

                // Í∑∏ÎûòÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
                updateChartData(false, currentFps, currentBitrate, currentLatency, currentJitter, currentPacketLoss);

                lastStatsTime = now;
            } catch (err) {
                console.error('Stats update failed:', err);
            }
        }

        // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë
        function startStatsMonitoring(isBroadcaster) {
            // Í∏∞Ï°¥ Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
            if (statsInterval) {
                clearInterval(statsInterval);
            }

            // Í∑∏ÎûòÌîÑ Ï¥àÍ∏∞Ìôî
            if (isBroadcaster) {
                if (!broadcasterChart) {
                    initBroadcasterChart();
                }
            } else {
                if (!viewerChart) {
                    initViewerChart();
                }
            }

            // 1Ï¥àÎßàÎã§ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            statsInterval = setInterval(() => {
                if (isBroadcaster) {
                    updateBroadcasterStats();
                } else {
                    updateViewerStats();
                }
            }, 1000);
        }

        // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ
        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            lastBytesSent = 0;
            lastBytesReceived = 0;
            lastStatsTime = 0;

            // Í∑∏ÎûòÌîÑ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
            chartData.broadcaster.labels = [];
            chartData.broadcaster.fps = [];
            chartData.broadcaster.bitrate = [];
            chartData.broadcaster.packetLoss = [];
            chartData.viewer.labels = [];
            chartData.viewer.fps = [];
            chartData.viewer.bitrate = [];
            chartData.viewer.latency = [];
            chartData.viewer.jitter = [];
            chartData.viewer.packetLoss = [];
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú URL ÌååÎùºÎØ∏ÌÑ∞ Ï≤¥ÌÅ¨
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const peerId = urlParams.get('id');

            if (peerId) {
                // QR ÏΩîÎìúÎ°ú Ï†ëÏÜçÌïú Í≤ΩÏö∞ ÏûêÎèôÏúºÎ°ú ÏãúÏ≤≠ Î™®ÎìúÎ°ú Ï†ÑÌôò
                setMode('viewer');
                document.getElementById('remotePeerId').value = peerId;
                // 1Ï¥à ÌõÑ ÏûêÎèô Ïó∞Í≤∞ (ÌéòÏù¥ÏßÄ Î°úÎî© ÏôÑÎ£å ÎåÄÍ∏∞)
                setTimeout(() => {
                    connectToStream();
                }, 1000);
            }
        });

        // Î™®Îìú Ï†ÑÌôò
        function setMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));

            if (mode === 'broadcast') {
                document.querySelector('.mode-btn:nth-child(1)').classList.add('active');
                document.getElementById('broadcast-panel').classList.add('active');
            } else {
                document.querySelector('.mode-btn:nth-child(2)').classList.add('active');
                document.getElementById('viewer-panel').classList.add('active');
            }

            // Ïù¥Ï†Ñ Ïó∞Í≤∞ Ï†ïÎ¶¨
            cleanup();
        }

        // ÏÜ°Ï∂ú ÏãúÏûë
        async function startBroadcast() {
            try {
                showStatus('broadcastStatus', 'Accessing webcam...', 'info');

                // ÏõπÏ∫† Ïä§Ìä∏Î¶º ÌöçÎìù (ÏûêÎèô Ìï¥ÏÉÅÎèÑ - Í∞ÄÎä•Ìïú ÏµúÎåÄ)
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: true
                });

                // Î°úÏª¨ ÎπÑÎîîÏò§ ÌëúÏãú
                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('broadcastInfo').style.display = 'block';
                document.getElementById('startBroadcast').style.display = 'none';

                // Peer Ï¥àÍ∏∞Ìôî (ÏûêÎèô ÏÑ§Ï†ï)
                peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    document.getElementById('myPeerId').value = id;

                    // QR ÏΩîÎìú ÏÉùÏÑ±
                    const qrUrl = `https://hwkim3330.github.io/cam/?id=${id}`;
                    const qrContainer = document.getElementById('qrcode');

                    // Í∏∞Ï°¥ QR ÏΩîÎìú Ï†úÍ±∞
                    qrContainer.innerHTML = '';

                    // ÏÉà QR ÏΩîÎìú ÏÉùÏÑ±
                    qrCodeInstance = new QRCode(qrContainer, {
                        text: qrUrl,
                        width: 200,
                        height: 200,
                        colorDark: "#1d1d1f",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H
                    });

                    showStatus('broadcastStatus', 'Broadcast ready! Share your ID.', 'success');
                });

                peer.on('call', (call) => {
                    // ÏãúÏ≤≠ÏûêÏùò Ïó∞Í≤∞ ÏàòÎùΩ (ÎπÑÌä∏Î†àÏù¥Ìä∏ Ï†úÌïú ÏóÜÏùå - ÏûêÎèô)
                    call.answer(localStream);
                    connections.add(call);
                    updateViewerCount();

                    // ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
                    if (connections.size === 1) {
                        startStatsMonitoring(true);
                    }

                    call.on('close', () => {
                        connections.delete(call);
                        updateViewerCount();

                        // Î™®Îì† Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÄÎ©¥ ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
                        if (connections.size === 0) {
                            stopStatsMonitoring();
                        }
                    });

                    showStatus('broadcastStatus', 'Viewer connected!', 'success');
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    if (err.type === 'network' || err.type === 'server-error') {
                        showStatus('broadcastStatus', 'Connection error. Please try again.', 'error');
                    } else if (err.type === 'unavailable-id') {
                        showStatus('broadcastStatus', 'ID conflict. Refresh page.', 'error');
                    } else {
                        showStatus('broadcastStatus', 'Error: ' + err.message, 'error');
                    }
                });

            } catch (err) {
                showStatus('broadcastStatus', 'Webcam access failed: ' + err.message, 'error');
            }
        }

        // Ïä§Ìä∏Î¶º Ïó∞Í≤∞ (ÏãúÏ≤≠Ïûê)
        async function connectToStream() {
            const remotePeerId = document.getElementById('remotePeerId').value.trim();

            if (!remotePeerId) {
                showStatus('viewerStatus', 'Please enter ID', 'error');
                return;
            }

            try {
                showStatus('viewerStatus', 'Connecting...', 'info');
                document.getElementById('connectBtn').disabled = true;

                // ÎçîÎØ∏ Ïä§Ìä∏Î¶º ÏÉùÏÑ± (WebRTC Ïó∞Í≤∞ÏùÑ ÏúÑÌï¥ ÌïÑÏöî)
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const dummyStream = canvas.captureStream(1); // 1fps ÎçîÎØ∏ Ïä§Ìä∏Î¶º

                // ÎçîÎØ∏ Ïò§ÎîîÏò§ Ìä∏Îûô Ï∂îÍ∞Ä
                const audioContext = new AudioContext();
                const oscillator = audioContext.createOscillator();
                const dst = oscillator.connect(audioContext.createMediaStreamDestination());
                oscillator.start();
                dummyStream.addTrack(dst.stream.getAudioTracks()[0]);

                // Peer Ï¥àÍ∏∞Ìôî
                peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                peer.on('open', () => {
                    // ÏÜ°Ï∂úÏûêÏóêÍ≤å Ïó∞Í≤∞ (ÎçîÎØ∏ Ïä§Ìä∏Î¶º Ï†ÑÏÜ°)
                    currentCall = peer.call(remotePeerId, dummyStream);

                    currentCall.on('stream', (remoteStream) => {
                        console.log('Stream received:', remoteStream);
                        document.getElementById('remoteVideo').srcObject = remoteStream;
                        document.getElementById('remoteVideoContainer').style.display = 'block';
                        showStatus('viewerStatus', 'Streaming!', 'success');
                        document.getElementById('connectBtn').disabled = false;

                        // ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
                        startStatsMonitoring(false);
                    });

                    currentCall.on('close', () => {
                        showStatus('viewerStatus', 'Connection closed', 'error');
                        document.getElementById('remoteVideoContainer').style.display = 'none';
                        document.getElementById('connectBtn').disabled = false;

                        // ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
                        stopStatsMonitoring();
                    });

                    currentCall.on('error', (err) => {
                        console.error('Call Error:', err);
                        showStatus('viewerStatus', 'Ïó∞Í≤∞ Error: ' + err.message, 'error');
                        document.getElementById('connectBtn').disabled = false;

                        // ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
                        stopStatsMonitoring();
                    });
                });

                peer.on('error', (err) => {
                    console.error('Peer Error:', err);
                    showStatus('viewerStatus', 'Error: ' + err.message, 'error');
                    document.getElementById('connectBtn').disabled = false;
                });

            } catch (err) {
                console.error('Connection failed:', err);
                showStatus('viewerStatus', 'Connection failed: ' + err.message, 'error');
                document.getElementById('connectBtn').disabled = false;
            }
        }

        // ID Î≥µÏÇ¨
        function copyPeerId() {
            const peerIdInput = document.getElementById('myPeerId');
            peerIdInput.select();
            document.execCommand('copy');

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        // ÏãúÏ≤≠Ïûê Ïàò ÏóÖÎç∞Ïù¥Ìä∏
        function updateViewerCount() {
            document.getElementById('viewerCount').textContent = connections.size;
        }

        // ÏÉÅÌÉú Î©îÏãúÏßÄ ÌëúÏãú
        function showStatus(elementId, message, type) {
            const statusEl = document.getElementById(elementId);
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // Ï†ïÎ¶¨
        function cleanup() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (peer) {
                peer.destroy();
                peer = null;
            }
            if (currentCall) {
                currentCall.close();
                currentCall = null;
            }
            connections.clear();

            // QR ÏΩîÎìú Ï¥àÍ∏∞Ìôî
            const qrContainer = document.getElementById('qrcode');
            if (qrContainer) {
                qrContainer.innerHTML = '';
            }
            qrCodeInstance = null;

            // ÌÜµÍ≥Ñ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
            stopStatsMonitoring();
        }

        // ÌéòÏù¥ÏßÄ Ï¢ÖÎ£å Ïãú Ï†ïÎ¶¨
        window.addEventListener('beforeunload', cleanup);
    </script>
</body>
</html>
